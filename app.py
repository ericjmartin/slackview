#!/usr/bin/env python

# Copyright (c) 2021 Dennis Mellican
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from gevent import monkey
monkey.patch_all()

from flask_socketio import SocketIO, emit, join_room, leave_room
from flask import Flask, render_template, url_for, copy_current_request_context, redirect
from threading import Thread, Event

from slack_sdk.web import WebClient
from slack_sdk.socket_mode import SocketModeClient
from slack_sdk.errors import SlackApiError
from slack_sdk.socket_mode.response import SocketModeResponse
from slack_sdk.socket_mode.request import SocketModeRequest

import logging
from logging.config import dictConfig
import json
import os
from pathlib import Path
import re
import socket
import sys
import threading
import time
import yaml

class Config():

    def __init__(self):
        current_dir = os.path.dirname(os.path.abspath(__file__))
        if Path(current_dir + '/config.yml').is_file():
            self.config_file = current_dir + '/config.yml'

        # For Docker config mount volume
        if Path('/config/config.yml').is_file():
            self.config_file = '/config/config.yml'
        self.last_updated = ''

    def load_config(self):
        """Load config file if it has changed.
        """
        if (self.last_updated != os.stat(self.config_file).st_mtime):
            with open(self.config_file, 'r') as stream:
                self.config = yaml.load(stream, Loader=yaml.FullLoader)
            self.last_updated = os.stat(self.config_file).st_mtime
            return self.config

config_file = Config()
config_file.load_config()
config = config_file.config

if 'loglevel' in config:
    loglevel = config['loglevel']
else:
    loglevel = 'INFO'

logging.config.dictConfig({
    'version': 1,
    'formatters': {'default': {
        'format': '[%(asctime)s] %(levelname)s: %(message)s',
    }},
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'default',
            'stream': 'ext://sys.stdout',
        },
        'logfile': {
            'formatter': 'default',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': 'slackview.log',
            'mode': 'a',
            'maxBytes': 1048576,
            'backupCount': 10
        }
    },
    'root': {
        'level': loglevel,
        'handlers': ['console','logfile']
    }
})
logging.getLogger('werkzeug').disabled = True
logger = logging.getLogger(__name__)
os.environ['WERKZEUG_RUN_MAIN'] = 'true'

def in_config(key):
    if key in config:
        return True
    else:
        return False

def terminate(message):
    logging.error(message)
    sys.exit()

def preflight_check():
  global host_ip
  global protocol

  if not in_config('slack_bot_token'):
      terminate('[ERROR] slack_bot_token not defined in config.yml file.')

  if not in_config('slack_app_token'):
      terminate('[ERROR] slack_bot_token not defined in config.yml file.')

  if not in_config('history_limit'):
      config['history_limit'] = 25

  if not in_config('theme'):
      config['theme'] = 'style'
  config['theme'] = config['theme'].replace("\.css$",'')

  if not in_config('host'):
      config['host'] = 'localhost'
  if config['host'] == '0.0.0.0':
      s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
      s.connect(("1.1.1.1", 80))
      host_ip = s.getsockname()[0]
  else:
      host_ip = config['host']

  if not in_config('port'):
      config['port'] = 5000

  if in_config('certfile'):
      if not os.path.isfile(config['certfile']):
          terminate("[ERROR] certfile %s does not exist." % config['certfile'])

  if in_config('keyfile'):
      if not os.path.isfile(config['keyfile']):
          terminate("[ERROR] keyfile %s does not exist." % config['keyfile'])
      protocol = 'https'
  else:
      protocol = 'http'

  if not in_config('web_address'):
      config['web_address'] = "%s://%s:%s" % (protocol,host_ip,config['port'])

preflight_check()

global all_emojis
global user_list

socketClient = SocketModeClient(
    app_token=config['slack_app_token'],
    web_client=WebClient(token=config['slack_bot_token'])
)
webClient = WebClient(token=config['slack_bot_token'])


def channel_list(channels=None, cursor=''):
    '''
     Modified for multi-page processing and filtering based on channel membership
     '''
    try:
        if channels == None: channels = []
        result = webClient.conversations_list(exclude_archived=True,cursor=cursor, limit=50)
        for ch in result['channels']:
            if ch['is_member']:
                channels.append(ch)
        
        cursor = result['response_metadata']['next_cursor']
        if cursor != '':
            channel_list(channels=channels,cursor=cursor)

        return channels
    except SlackApiError as e:
        logger.error("Error fetching channels: {}".format(e))
        return

def get_channel_by_id(slackChannelId):
    try:
        result = webClient.conversations_list()
        for channel in result['channels']:
            if channel['id'] == slackChannelId:
                return channel
    except SlackApiError as e:
        logger.error("Error fetching channels: {}".format(e))

def get_channel_by_name(slackChannelName):
    try:
        channels = channel_list()
        for channel in channels:
            if channel['name'] == slackChannelName:
                return channel
    except SlackApiError as e:
        logger.error("Error fetching channels: {}".format(e))

def get_channel_history(channel_id, history_count):
    conversation_history = []
    try:
        result = webClient.conversations_history(channel=channel_id,limit=history_count)
        conversation_history = list(reversed(result['messages']))
    except SlackApiError as e:
        logger.error("Error creating conversation: {}".format(e))
    
    message_cache_file = '.channel-cache.tmp.json'
    try:
        with open(message_cache_file, 'w') as f:
            json.dump(conversation_history, f, indent=4, sort_keys=True)
    except Exception as e:
        logger.error("Could not write message cache file: %s" % e)

    return conversation_history

def render_message(message):
    logger.debug("Message to render: %s" % message)
    if message['type'] == 'message' \
        and message.get('subtype') is None:
         payload = render_user_message(message)
         socketio.emit('newmessage', {'text': payload}, namespace='/watch', room=room)

    # Process bot messages
    if message['type'] == 'message' \
        and message.get('subtype') == 'bot_message':
         payload = render_bot_message(message)
         socketio.emit('newmessage', {'text': payload}, namespace='/watch', room=room)

def get_all_users():
    users_cache_file = '.users-cache.tmp.json'
    try:
        with open(users_cache_file) as f:
            data = json.load(f)
        return data
    except Exception:
        pass

    try:
        result = webClient.users_list()
    except SlackApiError as e:
        logger.error("Error retrieving user list: {}".format(e))

    userlistIndexed = {}
    for user in result['members']:
        userlistIndexed[user['id']] = user

    try:
        with open(users_cache_file, 'w') as f:
            json.dump(userlistIndexed, f, indent=4, sort_keys=True)
    except Exception as e:
        logger.error("Could not write users cache file: %s" % e)

    return userlistIndexed

def user_id_to_name(userId):
    user = user_list[userId];
    if 'real_name' in user:
        return user['real_name']
    if 'name' in user:
        return user['name']
    return 'Unknown';

def get_all_emojis():
    emoji_cache_file = '.emoji-cache.tmp.json'
    emojis_json = 'emojis.json'
    try:
        with open(emoji_cache_file) as f:
            data = json.load(f)
        return data
    except Exception:
        pass
    
    try:
        result = webClient.emoji_list()
    except SlackApiError as e:
        logger.error("Error retrieving emoji list: {}".format(e))

    all_emojis = result['emoji']

    try:
        with open(emojis_json) as f:
            standard_emojis = json.load(f)
    except Exception as e:
        logger.error("Could not read emojis.json: %s" % e)
    for emoji in standard_emojis:
        as_html = '&#x' + emoji['unified'].replace('-',';&#x') + ';'
        all_emojis[emoji['short_name']] = as_html                

    try:
        with open(emoji_cache_file, 'w') as f:
            json.dump(all_emojis, f, indent=4, sort_keys=True)
    except Exception as e:
        logger.error("Could not write emojis cache file: %s" % e)

    return all_emojis

def render_avatar(user):
    return '<img class="avatar" src="' + user['profile']['image_48'] + '" aria-hidden="true" title="">'

def render_icon(icon):
    icon = icon.replace(':','').lower()
    return '<span class="emoji">' + all_emojis[icon] + '</span>'

def replace_markdown(message):

    # Replace :emoji:
    matches = re.findall(':([a-zA-Z0-9_\-]+)(::[a-zA-Z0-9_\-])?:', message)
    for icon in matches:
        try:
            message = message.replace(':' + icon[0] + ':',all_emojis[icon[0].lower()])
        except Exception:
            pass

    # Replace *bold* with <b>bold</b>
    message = re.sub(r"\*([^\*]*)\*", r"<b>\1</b>", message)

    # Replace _italics_ with <i>italicsl</i>
    message = re.sub(r"\_([^\*]*)\_", r"<i>\1</i>", message)

    return message

def render_user_message(message):
    html = '<div class="slack-message">'
    html += render_avatar(user_list[message['user']])
    html += '<div class="content">'
    html += '<strong class="username">' + user_id_to_name(message['user']) + '</strong> '
    timeArray = time.localtime(float(message['ts']))
    html += '<small class="timestamp">' + time.strftime("%Y-%m-%d %H:%M:%S", timeArray) + '</small>'
    html += '<small class="timestamp">' + time.strftime("%Y-%m-%d %H:%M:%S", timeArray) + '</small>'
    html += '<div class="message">' + replace_markdown(message["text"]) + '</div>'
    html += '</div>'
    html += '</div>'
    return html

def render_bot_message(message):
    html = '<div class="slack-message">'
    try:
        if 'emoji' in message['icons']:
            icon = message['icons']['emoji']
            html += render_icon(icon)
        elif 'image_64' in message['icons']:
            message['icons']['image_64']
            html += '<img class="avatar" src="' + message['icons']['image_64'] + '" aria-hidden="true" title="">'
    except Exception as e:
        #TODO: Find bot_id icon image.
        logger.warning("Could not find an emoji / icon %s" % e)
    html += '<div class="content">'
    html += '<strong class="username">' + message['username'] + '</strong> '
    timeArray = time.localtime(float(message['ts']))
    html += '<small class="timestamp">' + time.strftime("%Y-%m-%d %H:%M:%S", timeArray) + '</small>'
    html += '<div class="message">' + replace_markdown(message["text"]) + '</div>'
        
#TODO
#    if (isset($message['reactions'])) {
#        $html .= render_reactions($message['reactions']);
#    }
    html += '</div>'
    html += '</div>'
    return html

def process(client: SocketModeClient, req: SocketModeRequest):
    if req.type == 'events_api':
        logger.info("Event detected: %s" % req.payload["event"])
        # Acknowledge the request anyway
        response = SocketModeResponse(envelope_id=req.envelope_id)
        socketClient.send_socket_mode_response(response)

        # Process user messages
        if req.payload['event']['type'] == 'message' \
            and req.payload['event'].get('subtype') is None:
             payload = render_user_message(req.payload['event'])
             room_name = get_channel_by_id(req.payload['event'].get('channel'))
             socketio.emit('newmessage', {'text': payload}, namespace='/watch', room=room_name['name'])

        # Process bot messages
        if req.payload['event']['type'] == 'message' \
            and req.payload['event'].get('subtype') == 'bot_message':
             payload = render_bot_message(req.payload['event'])
             room_name = get_channel_by_id(req.payload['event'].get('channel'))
             socketio.emit('newmessage', {'text': payload}, namespace='/watch', room=room_name['name'])
    else: 
        logger.info('Something else')

app = Flask(__name__)
app.config['SECRET_KEY'] = 'secret!'
app.config['DEBUG'] = True

socketio = SocketIO(app, async_mode='gevent', logger=True, engineio_logger=True, cors_allowed_origins="*")
thread = None

def watch_slack():
    print('thread started')
    socketClient.socket_mode_request_listeners.append(process)
    print('thread connected')
    socketClient.connect()
    print('thread waiting')
    Event().wait()

@app.route('/')
def index():
    global thread
    if thread is None:
        thread = Thread(target=watch_slack)
        thread.daemon = True
        thread.start()
    if 'channel_default' in config:
        return redirect('/slackview/' + config['channel_default'], 307)
    else:
        return render_template('index.html',
                               channels=channel_list())

@app.route('/slackview/<channel_name>')
def watch(channel_name):
    global channel
    global channel_history
    global thread
    if thread is None:
        print("NOOOO")
    channel = get_channel_by_name(channel_name)
    try:
        channel_history = get_channel_history(channel['id'],config['history_limit'])
    except Exception as e:
        print(e)
        return redirect('/', 307)
    return render_template('slackview.html',
                           web_address=config['web_address'],
                           theme=config['theme'])

@socketio.on('join', namespace='/watch')
def watch_connect(data):
    global room
    global room_id
    room = data['channel']
    join_room(room)
    logger.info("Client connected to %s" % room)

    for message in channel_history:
        render_message(message);

@socketio.on('disconnect', namespace='/watch')
def watch_disconnect(data):
    room = data['channel']
    join_room(room)
    logger.info('Client disconnected')

if __name__ == '__main__':
    logger.info("Slack View is running on %s" % (config['web_address']))
    all_emojis = get_all_emojis()
    user_list = get_all_users()
    if in_config('keyfile'):
        socketio.run(app, host=config['host'], port=config['port'], certfile=config['certfile'], keyfile=config['keyfile'])
    else:
        socketio.run(app, host=config['host'], port=config['port'])
    socketio.run(app, host=config['host'], port=config['port'])
